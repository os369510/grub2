From: Peter Jones <pjones@redhat.com>
Date: Wed, 12 Sep 2018 16:03:55 -0400
Subject: x86-efi: Make our own allocator for kernel stuff

This helps enable allocations above 4GB.

Signed-off-by: Peter Jones <pjones@redhat.com>
---
 grub-core/loader/i386/efi/linux.c | 201 +++++++++++++++++++++++---------------
 1 file changed, 124 insertions(+), 77 deletions(-)

diff --git a/grub-core/loader/i386/efi/linux.c b/grub-core/loader/i386/efi/linux.c
index 3cede18..adc027c 100644
--- a/grub-core/loader/i386/efi/linux.c
+++ b/grub-core/loader/i386/efi/linux.c
@@ -43,6 +43,65 @@ static char *linux_cmdline;
 
 #define BYTES_TO_PAGES(bytes)   (((bytes) + 0xfff) >> 12)
 
+struct allocation_choice {
+    grub_efi_physical_address_t addr;
+    grub_efi_allocate_type_t alloc_type;
+};
+
+static struct allocation_choice max_addresses[] =
+  {
+    { GRUB_EFI_MAX_ALLOCATION_ADDRESS, GRUB_EFI_ALLOCATE_MAX_ADDRESS },
+    { GRUB_EFI_MAX_ALLOCATION_ADDRESS, GRUB_EFI_ALLOCATE_MAX_ADDRESS },
+    { GRUB_EFI_MAX_ALLOCATION_ADDRESS, GRUB_EFI_ALLOCATE_MAX_ADDRESS },
+    { 0, 0 }
+  };
+
+static inline void
+kernel_free(void *addr, grub_efi_uintn_t size)
+{
+  if (addr && size)
+    grub_efi_free_pages ((grub_efi_physical_address_t)(grub_addr_t)addr,
+			 BYTES_TO_PAGES(size));
+}
+
+static void *
+kernel_alloc(grub_efi_uintn_t size, const char * const errmsg)
+{
+  void *addr = 0;
+  unsigned int i;
+  grub_efi_physical_address_t prev_max = 0;
+
+  for (i = 0; max_addresses[i].addr != 0 && addr == 0; i++)
+    {
+      grub_uint64_t max = max_addresses[i].addr;
+      grub_efi_uintn_t pages;
+
+      if (max == prev_max)
+	continue;
+
+      pages = BYTES_TO_PAGES(size);
+      grub_dprintf ("linuxefi", "Trying to allocate %lu pages from %p\n",
+		    pages, (void *)max);
+
+      prev_max = max;
+      addr = grub_efi_allocate_pages_real (max, pages,
+					   max_addresses[i].alloc_type,
+					   GRUB_EFI_LOADER_DATA);
+      if (addr)
+	grub_dprintf ("linuxefi", "Allocated at %p\n", addr);
+    }
+
+  while (grub_error_pop ())
+    {
+      ;
+    }
+
+  if (addr == NULL)
+    grub_error (GRUB_ERR_OUT_OF_MEMORY, "%s", errmsg);
+
+  return addr;
+}
+
 static grub_err_t
 grub_linuxefi_boot (void)
 {
@@ -58,19 +117,12 @@ grub_linuxefi_unload (void)
 {
   grub_dl_unref (my_mod);
   loaded = 0;
-  if (initrd_mem)
-    grub_efi_free_pages ((grub_efi_physical_address_t)(grub_addr_t)initrd_mem,
-			 BYTES_TO_PAGES(params->ramdisk_size));
-  if (linux_cmdline)
-    grub_efi_free_pages ((grub_efi_physical_address_t)(grub_addr_t)
-			 linux_cmdline,
-			 BYTES_TO_PAGES(params->cmdline_size + 1));
-  if (kernel_mem)
-    grub_efi_free_pages ((grub_efi_physical_address_t)(grub_addr_t)kernel_mem,
-			 BYTES_TO_PAGES(kernel_size));
-  if (params)
-    grub_efi_free_pages ((grub_efi_physical_address_t)(grub_addr_t)params,
-			 BYTES_TO_PAGES(16384));
+
+  kernel_free(initrd_mem, params->ramdisk_size);
+  kernel_free(linux_cmdline, params->cmdline_size + 1);
+  kernel_free(kernel_mem, kernel_size);
+  kernel_free(params, sizeof(*params));
+
   return GRUB_ERR_NONE;
 }
 
@@ -112,18 +164,13 @@ grub_cmd_initrd (grub_command_t cmd __attribute__ ((unused)),
 	}
     }
 
-  initrd_mem = grub_efi_allocate_pages_max (GRUB_EFI_MAX_ALLOCATION_ADDRESS, BYTES_TO_PAGES(size));
-
-  if (!initrd_mem)
-    {
-      grub_error (GRUB_ERR_OUT_OF_MEMORY, N_("can't allocate initrd"));
-      goto fail;
-    }
-
+  initrd_mem = kernel_alloc(size, N_("can't allocate initrd"));
+  if (initrd_mem == NULL)
+    goto fail;
   grub_dprintf ("linuxefi", "initrd_mem = %p\n", initrd_mem);
 
   params->ramdisk_size = size;
-  params->ramdisk_image = (grub_addr_t) initrd_mem;
+  params->ramdisk_image = initrd_mem;
 
   ptr = initrd_mem;
 
@@ -186,7 +233,6 @@ grub_cmd_linux (grub_command_t cmd __attribute__ ((unused)),
   filelen = grub_file_size (file);
 
   kernel = grub_malloc(filelen);
-
   if (!kernel)
     {
       grub_error (GRUB_ERR_OUT_OF_MEMORY, N_("cannot allocate kernel buffer"));
@@ -201,31 +247,8 @@ grub_cmd_linux (grub_command_t cmd __attribute__ ((unused)),
     }
 
   lh = (struct linux_i386_kernel_header *)kernel;
-  grub_dprintf ("linux", "original lh is at %p\n", kernel);
-
-  params = grub_efi_allocate_pages_max (GRUB_EFI_MAX_ALLOCATION_ADDRESS,
-					BYTES_TO_PAGES(sizeof(*params)));
-  if (! params)
-    {
-      grub_error (GRUB_ERR_OUT_OF_MEMORY, "cannot allocate kernel parameters");
-      goto fail;
-    }
+  grub_dprintf ("linuxefi", "original lh is at %p\n", kernel);
 
-  grub_dprintf ("linuxefi", "params = %p\n", params);
-
-  grub_memset (params, 0, sizeof(*params));
-
-  setup_header_end_offset = *((grub_uint8_t *)kernel + 0x201);
-  grub_dprintf ("linuxefi", "copying %" PRIuGRUB_SIZE " bytes from %p to %p\n",
-		MIN((grub_size_t)0x202+setup_header_end_offset,
-		    sizeof (*params)) - 0x1f1,
-		(grub_uint8_t *)kernel + 0x1f1,
-		(grub_uint8_t *)params + 0x1f1);
-  grub_memcpy ((grub_uint8_t *)params + 0x1f1,
-	       (grub_uint8_t *)kernel + 0x1f1,
-		MIN((grub_size_t)0x202+setup_header_end_offset,sizeof (*params)) - 0x1f1);
-  lh = (struct linux_i386_kernel_header *)params;
-  grub_dprintf ("linuxefi", "final lh is at %p\n", lh);
   grub_dprintf ("linuxefi", "checking lh->boot_flag\n");
   if (lh->boot_flag != grub_cpu_to_le16 (0xaa55))
     {
@@ -254,7 +277,7 @@ grub_cmd_linux (grub_command_t cmd __attribute__ ((unused)),
       goto fail;
     }
 
-#if defined(__x86_64__) || defined(__aarch64__)
+#if defined(__x86_64__)
   grub_dprintf ("linuxefi", "checking lh->xloadflags\n");
   if (!(lh->xloadflags & LINUX_XLF_KERNEL_64))
     {
@@ -273,15 +296,42 @@ grub_cmd_linux (grub_command_t cmd __attribute__ ((unused)),
     }
 #endif
 
-  grub_dprintf ("linuxefi", "setting up cmdline\n");
-  linux_cmdline = grub_efi_allocate_pages_max(GRUB_EFI_MAX_ALLOCATION_ADDRESS,
-					 BYTES_TO_PAGES(lh->cmdline_size + 1));
-  if (!linux_cmdline)
+#if defined(__x86_64__)
+  if (lh->xloadflags & LINUX_XLF_CAN_BE_LOADED_ABOVE_4G)
     {
-      grub_error (GRUB_ERR_OUT_OF_MEMORY, N_("can't allocate cmdline"));
-      goto fail;
+      grub_dprintf ("linuxefi", "Loading kernel above 4GB is supported; enabling.\n");
+      max_addresses[2].addr = GRUB_EFI_MAX_USABLE_ADDRESS;
     }
+  else
+    {
+      grub_dprintf ("linuxefi", "Loading kernel above 4GB is not supported\n");
+    }
+#endif
+
+  params = kernel_alloc (sizeof(*params), "cannot allocate kernel parameters");
+  if (!params)
+    goto fail;
+  grub_dprintf ("linuxefi", "params = %p\n", params);
+
+  grub_memset (params, 0, sizeof(*params));
+
+  setup_header_end_offset = *((grub_uint8_t *)kernel + 0x201);
+  grub_dprintf ("linuxefi", "copying %lu bytes from %p to %p\n",
+		MIN((grub_size_t)0x202+setup_header_end_offset,
+		    sizeof (*params)) - 0x1f1,
+		(grub_uint8_t *)kernel + 0x1f1,
+		(grub_uint8_t *)params + 0x1f1);
+  grub_memcpy ((grub_uint8_t *)params + 0x1f1,
+	       (grub_uint8_t *)kernel + 0x1f1,
+		MIN((grub_size_t)0x202+setup_header_end_offset,sizeof (*params)) - 0x1f1);
 
+  lh = (struct linux_i386_kernel_header *)params;
+  grub_dprintf ("linuxefi", "new lh is at %p\n", lh);
+
+  grub_dprintf ("linuxefi", "setting up cmdline\n");
+  linux_cmdline = kernel_alloc (lh->cmdline_size + 1, N_("can't allocate cmdline"));
+  if (!linux_cmdline)
+    goto fail;
   grub_dprintf ("linuxefi", "linux_cmdline = %p\n", linux_cmdline);
 
   grub_memcpy (linux_cmdline, LINUX_IMAGE, sizeof (LINUX_IMAGE));
@@ -290,25 +340,26 @@ grub_cmd_linux (grub_command_t cmd __attribute__ ((unused)),
 			      lh->cmdline_size - (sizeof (LINUX_IMAGE) - 1),
 			      GRUB_VERIFY_KERNEL_CMDLINE);
 
-  grub_dprintf ("linuxefi", "setting lh->cmd_line_ptr to %p\n",
-          linux_cmdline);
-  lh->cmd_line_ptr = (grub_addr_t)linux_cmdline;
+  grub_dprintf ("linuxefi", "cmdline:%s\n", linux_cmdline);
+  grub_dprintf ("linuxefi", "setting lh->cmd_line_ptr to 0x%08x\n",
+		linux_cmdline);
+  lh->cmd_line_ptr = linux_cmdline;
 
   handover_offset = lh->handover_offset;
-  grub_dprintf("linux", "handover_offset: 0x%08x\n", handover_offset);
+  grub_dprintf("linuxefi", "handover_offset: 0x%08x\n", handover_offset);
 
   start = (lh->setup_sects + 1) * 512;
 
-  kernel_mem = grub_efi_allocate_fixed(lh->pref_address,
-				       BYTES_TO_PAGES(lh->init_size));
-  if (!kernel_mem)
+  grub_dprintf ("linuxefi", "lh->pref_address: %p\n", (void *)(grub_addr_t)lh->pref_address);
+  if (lh->pref_address < (grub_uint64_t)GRUB_EFI_MAX_ALLOCATION_ADDRESS)
     {
-      grub_error_pop();
-      grub_error (GRUB_ERR_OUT_OF_MEMORY, N_("can't allocate kernel"));
-      goto fail;
+      max_addresses[0].addr = lh->pref_address;
+      max_addresses[0].alloc_type = GRUB_EFI_ALLOCATE_ADDRESS;
     }
-
-  grub_dprintf ("linuxefi", "kernel_mem = %p\n", kernel_mem);
+  kernel_mem = kernel_alloc (lh->init_size, N_("can't allocate kernel"));
+  if (!kernel_mem)
+    goto fail;
+  grub_dprintf("linuxefi", "kernel_mem = %p\n", kernel_mem);
 
   grub_loader_set (grub_linuxefi_boot, grub_linuxefi_unload, 0);
   loaded=1;
@@ -341,18 +392,14 @@ grub_cmd_linux (grub_command_t cmd __attribute__ ((unused)),
       loaded = 0;
     }
 
-  if (linux_cmdline && lh && !loaded)
-    grub_efi_free_pages ((grub_efi_physical_address_t)(grub_addr_t)
-			 linux_cmdline,
-			 BYTES_TO_PAGES(lh->cmdline_size + 1));
-
-  if (kernel_mem && !loaded)
-    grub_efi_free_pages ((grub_efi_physical_address_t)(grub_addr_t)kernel_mem,
-			 BYTES_TO_PAGES(kernel_size));
+  if (!loaded)
+    {
+      if (lh)
+	kernel_free (linux_cmdline, lh->cmdline_size + 1);
 
-  if (params && !loaded)
-    grub_efi_free_pages ((grub_efi_physical_address_t)(grub_addr_t)params,
-			 sizeof(*params));
+      kernel_free (kernel_mem, kernel_size);
+      kernel_free (params, sizeof(*params));
+    }
 
   return grub_errno;
 }
